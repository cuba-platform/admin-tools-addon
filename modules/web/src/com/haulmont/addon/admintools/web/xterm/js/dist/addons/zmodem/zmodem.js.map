{"version":3,"file":"zmodem.js","sources":["../../../src/addons/zmodem/zmodem.ts","../../../node_modules/browser-pack/_prelude.js"],"sourcesContent":["/**\n *\n * Allow xterm.js to handle ZMODEM uploads and downloads.\n *\n * This addon is a wrapper around zmodem.js. It adds the following to the\n *  Terminal class:\n *\n * - function `zmodemAttach(<WebSocket>, <Object>)` - creates a Zmodem.Sentry\n *      on the passed WebSocket object. The Object passed is optional and\n *      can contain:\n *          - noTerminalWriteOutsideSession: Suppress writes from the Sentry\n *            object to the Terminal while there is no active Session. This\n *            is necessary for compatibility with, for example, the\n *            `attach.js` addon.\n *\n * - event `zmodemDetect` - fired on Zmodem.Sentry’s `on_detect` callback.\n *      Passes the zmodem.js Detection object.\n *\n * - event `zmodemRetract` - fired on Zmodem.Sentry’s `on_retract` callback.\n *\n * You’ll need to provide logic to handle uploads and downloads.\n * See zmodem.js’s documentation for more details.\n *\n * **IMPORTANT:** After you confirm() a zmodem.js Detection, if you have\n *  used the `attach` or `terminado` addons, you’ll need to suspend their\n *  operation for the duration of the ZMODEM session. (The demo does this\n *  via `detach()` and a re-`attach()`.)\n */\n\nlet Zmodem;\n\nexport function zmodemAttach(term, ws, opts) {\n  if (!opts) opts = {};\n\n  var senderFunc = function _ws_sender_func(octets) {\n    ws.send(new Uint8Array(octets));\n  };\n\n  var zsentry;\n\n  function _shouldWrite() {\n    return !!zsentry.get_confirmed_session() || !opts.noTerminalWriteOutsideSession;\n  }\n\n  zsentry = new Zmodem.Sentry( {\n    to_terminal: function _to_terminal(octets) {\n      if (_shouldWrite()) {\n        term.write(\n          String.fromCharCode.apply(String, octets)\n        );\n      }\n    },\n\n    sender: senderFunc,\n\n    on_retract: function _on_retract() {\n      term.emit('zmodemRetract');\n    },\n\n    on_detect: function _on_detect(detection) {\n      term.emit('zmodemDetect', detection);\n    },\n  } );\n\n  function handleWSMessage(evt) {\n\n    //In testing with xterm.js’s demo the first message was\n    //always text even if the rest were binary. While that\n    //may be specific to xterm.js’s demo, ultimately we\n    //should reject anything that isn’t binary.\n    if (typeof evt.data === 'string') {\n      if (_shouldWrite()) {\n        term.write(evt.data);\n      }\n    }\n    else {\n      zsentry.consume(evt.data);\n    }\n  }\n\n  ws.binaryType = 'arraybuffer';\n  ws.addEventListener('message', handleWSMessage);\n}\n\nexport function apply(terminalConstructor) {\n  Zmodem = (typeof window == 'object') ? (<any>window).ZModem : {Browser: null};  // Nullify browser for tests\n\n  terminalConstructor.prototype.zmodemAttach = zmodemAttach.bind(this, this);\n  terminalConstructor.prototype.zmodemBrowser = Zmodem.Browser\n}\n",null],"names":[],"mappings":"ACAA;;;AD6BA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAnDA;AAqDA;AACA;AAEA;AACA;AACA;AALA;;;"}